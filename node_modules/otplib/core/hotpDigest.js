'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _hotpCounter = require('./hotpCounter');

var _hotpCounter2 = _interopRequireDefault(_hotpCounter);

var _hotpSecret = require('./hotpSecret');

var _hotpSecret2 = _interopRequireDefault(_hotpSecret);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Intermediate HOTP Digests
 *
 * @module core/hotpDigest
 * @param {string} secret - your secret that is used to generate the token
 * @param {number} counter - the OTP counter (usually it's an incremental count)
 * @param {string} options.algorithm - hmac algorithm
 * @param {function} options.createHmacSecret - the encoding function for secret
 * @param {string} options.encoding - the encoding of secret
 * @return {object}
 */
function hotpDigest(secret, counter, options) {
  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' || options == null) {
    throw new Error('[hotpDigest] argument 3 must be an object');
  }

  // Allow for direct digest use without going through hotpOptions
  var createHmacSecret = options.createHmacSecret || _hotpSecret2.default;

  // Convert secret to encoding for hmacSecret
  var hmacSecret = createHmacSecret(secret, options);

  // Ensure counter is a buffer or string (for HMAC creation)
  var hexCounter = (0, _hotpCounter2.default)(counter);

  // HMAC creation
  var cryptoHmac = _crypto2.default.createHmac(options.algorithm, hmacSecret);

  // Update HMAC with the counter
  return cryptoHmac.update(new Buffer(hexCounter, 'hex')).digest('hex');
}

exports.default = hotpDigest;